# マッチした場合は最初にマッチした文字列の開始位置が返る
'123-4567' =~ /\d{3}-\d{4}/
# マッチしない場合はnilが返る
'hello' =~ /\d{3}-\d{4}/

text = '私の誕生日は1977年7月17日です。'
m = /(\d+)年(\d+)月(\d+)日/.match(text)
# puts m[0]
# puts m[1]
# puts m[2]
# puts m[3]
# puts m[1..3]

# 名前付きのキャプチャ
text = '私の誕生日は1977年7月17日です。'
m = /(?<year>\d+)年(?<month>\d+)月(?<day>\d+)日/.match(text)
# シンボルで名前を指定
puts m[:year]
puts m[:month]
puts m[:day]
# 文字列で指定
puts m['year']
# 連番で指定
puts m[1]

# ローカル変数に割り当て
text = '私の誕生日は1977年2月34日です'
if /(?<year>\d+)年(?<month>\d+)月(?<day>\d+)日/ =~ text
    puts "#{year}/#{month}/#{day}"
end

# 組み込み変数でマッチの結果を取得する
text = '私の誕生日は1977年2月34日です'
# =~ や　matchメソッドを使うとマッチした結果が組み込み変数に代入される
text =~ /(\d+)年(\d+)月(\d+)日/
# MatchDateオブジェクトを取得
p $~
# マッチした部分全体を取得
p $&
# 1〜3番目を取得
p $1
# 最後のキャプチャの文字列を取得する
p $+

# scanメソッド
# キャプチャがあるとそれが配列の配列になって返る
p '1988年4月4日 2000年39月3日'.scan(/(\d+)年(\d+)月(\d+)日/)
# グループ化はしたいがキャプチャはしたくない時は　?:
p '1988年4月4日 2000年39月3日'.scan(/(?:\d+)年(?:\d+)月(?:\d+)日/)

# [], slice, slice!
# []に正規表現を渡すと、文字列から正規表現にマッチした部分を抜き出す
# マッチする部分が複数ある場合は最初にマッチした文字列が返る
text = '郵便番号は123-3455'
p text[/\d{3}-\d{4}/]

# キャプチャを使い第二引数で何番目のキャプチャを取得するか指定
text = '誕生日は12月3日です'
p text[/(\d+)月(\d+)日/]
p text[/(\d+)月(\d+)日/, 2]

text = '123, 456-345'
p text.gsub(/,|-/) { |matched| matched == ',' ? ':' : '/'}

text = '誕生日は12月3日です'
# p text.gsub(/(\d+)月(\d+)日/, '\1-\2')
t = text.gsub(/(\d+)月(\d+)日/) do
    "#{$1}-#{$2}"
end
puts t


